task,sample_num,extracted_code,average_percentage_correct,count_perfect_scores
f5b8619d,1,"def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row = []
        for elem in row:
            new_row.append(elem)
            new_row.append(8 if elem == 0 else elem)
        output_grid.append(new_row)
        output_grid.append([8 if elem == 0 else elem for elem in new_row])
    return output_grid",0.4366666666666667,0
f5b8619d,2,"def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row1 = []
        new_row2 = []
        for value in row:
            if value == 0:
                new_row1.extend([8, 8])
                new_row2.extend([8, 8])
            else:
                new_row1.extend([value, value])
                new_row2.extend([8, 8])
        output_grid.append(new_row1)
        output_grid.append(new_row2)
    return output_grid",0.38333333333333336,0
f5b8619d,3,"def transform(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    output_grid = []

    for i in range(rows * 2):
        row = []
        for j in range(cols * 2):
            if i % 2 == 0 and j % 2 == 0:
                row.append(input_grid[i // 2][j // 2])
            else:
                row.append(8)
        output_grid.append(row)

    return output_grid",0.4566666666666666,0
f5b8619d,4,"def transform(input_grid):
    if not input_grid or not input_grid[0]:
        return []

    rows = len(input_grid)
    cols = len(input_grid[0])

    # Initialize the output grid with zeros
    output_grid = [[0] * (2 * cols) for _ in range(2 * rows)]

    # Fill the output grid based on the transformation logic
    for i in range(rows):
        for j in range(cols):
            if input_grid[i][j] != 0:
                output_grid[2 * i][2 * j] = input_grid[i][j]
                output_grid[2 * i][2 * j + 1] = 8
                output_grid[2 * i + 1][2 * j] = 8
                output_grid[2 * i + 1][2 * j + 1] = 8

    return output_grid",0.41333333333333333,0
f5b8619d,5,"def transform(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    output_grid = []

    for i in range(rows):
        row1 = []
        row2 = []
        for j in range(cols):
            if input_grid[i][j] != 0:
                row1.extend([input_grid[i][j], 8])
                row2.extend([8, 8])
            else:
                row1.extend([0, 8])
                row2.extend([8, 8])
        output_grid.append(row1)
        output_grid.append(row2)

    return output_grid",0.4566666666666666,0
f5b8619d,6,"def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row1 = []
        new_row2 = []
        for val in row:
            if val == 0:
                new_row1.extend([8, 8])
                new_row2.extend([8, 8])
            else:
                new_row1.extend([val, val])
                new_row2.extend([val, val])
        output_grid.append(new_row1)
        output_grid.append(new_row2)
    return output_grid",0.3566666666666667,0
f5b8619d,7,"def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_rows = [[], []]
        for value in row:
            if value == 0:
                new_rows[0].extend([8, 8])
                new_rows[1].extend([8, 8])
            else:
                new_rows[0].extend([value, value])
                new_rows[1].extend([8, 8])
        output_grid.extend(new_rows)
    return output_grid",0.38333333333333336,0
f5b8619d,8,"def transform(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])

    # Initialize the output grid with zeros
    output_grid = [[0] * (2 * cols) for _ in range(2 * rows)]

    # Fill the output grid based on the transformation rules
    for i in range(rows):
        for j in range(cols):
            if input_grid[i][j] == 0:
                output_grid[2 * i][2 * j] = 8
                output_grid[2 * i][2 * j + 1] = 8
                output_grid[2 * i + 1][2 * j] = 8
                output_grid[2 * i + 1][2 * j + 1] = 8
            else:
                output_grid[2 * i][2 * j] = input_grid[i][j]
                output_grid[2 * i][2 * j + 1] = input_grid[i][j]
                output_grid[2 * i + 1][2 * j] = input_grid[i][j]
                output_grid[2 * i + 1][2 * j + 1] = input_grid[i][j]

    return output_grid",0.3566666666666667,0
f5b8619d,9,"def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row1 = []
        new_row2 = []
        for value in row:
            if value == 0:
                new_row1.extend([8, 8])
                new_row2.extend([8, 8])
            else:
                new_row1.extend([value, value])
                new_row2.extend([8, 8])
        output_grid.append(new_row1)
        output_grid.append(new_row2)
    return output_grid",0.38333333333333336,0
f5b8619d,10,"def transform(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])

    # Initialize the output grid with zeros
    output_grid = [[0] * (2 * cols) for _ in range(2 * rows)]

    # Fill the output grid based on the transformation rule
    for i in range(rows):
        for j in range(cols):
            if input_grid[i][j] == 0:
                output_grid[2 * i][2 * j] = 8
                output_grid[2 * i][2 * j + 1] = 8
                output_grid[2 * i + 1][2 * j] = 8
                output_grid[2 * i + 1][2 * j + 1] = 8
            else:
                output_grid[2 * i][2 * j] = input_grid[i][j]
                output_grid[2 * i][2 * j + 1] = input_grid[i][j]
                output_grid[2 * i + 1][2 * j] = input_grid[i][j]
                output_grid[2 * i + 1][2 * j + 1] = input_grid[i][j]

    return output_grid",0.3566666666666667,0
6b9890af,1,"def transform(input_grid):
    # Step 1: Remove all rows and columns that are entirely zeros
    non_zero_rows = [row for row in input_grid if any(cell != 0 for cell in row)]
    non_zero_cols = [[row[i] for row in non_zero_rows] for i in range(len(non_zero_rows[0])) if any(row[i] != 0 for row in non_zero_rows)]

    # Step 2: Combine adjacent identical values horizontally and vertically
    combined_rows = []
    for row in non_zero_rows:
        combined_row = []
        current_value = None
        for cell in row:
            if cell != current_value:
                if current_value is not None:
                    combined_row.append(current_value)
                current_value = cell
        if current_value is not None:
            combined_row.append(current_value)
        combined_rows.append(combined_row)

    combined_cols = []
    for col in non_zero_cols:
        combined_col = []
        current_value = None
        for cell in col:
            if cell != current_value:
                if current_value is not None:
                    combined_col.append(current_value)
                current_value = cell
        if current_value is not None:
            combined_col.append(current_value)
        combined_cols.append(combined_col)

    # Step 3: Determine the maximum length of the non-zero rows or columns
    max_length = max(len(row) for row in combined_rows)

    # Step 4: Pad the resulting grid with zeros to make it a square grid
    output_grid = []
    for row in combined_rows:
        padded_row = row + [0] * (max_length - len(row))
        output_grid.append(padded_row)

    return output_grid",0.0,0
6b9890af,2,,0.0,0
6b9890af,3,"def transform(input_grid: list[list[int]]) -> list[list[int]]:
    # Step 1: Remove columns that are entirely zeros
    non_zero_columns = [col for col in zip(*input_grid) if any(cell != 0 for cell in col)]
    cleaned_grid = [list(row) for row in zip(*non_zero_columns)]

    # Step 2: Determine the output grid size
    input_rows = len(cleaned_grid)
    input_cols = len(cleaned_grid[0])
    output_rows = max(1, input_rows // 2)
    output_cols = max(1, input_cols // 2)

    # Step 3: Downsample the grid
    output_grid = []
    for i in range(output_rows):
        row = []
        for j in range(output_cols):
            # Merge adjacent non-zero values into a single value
            merged_value = 0
            for di in range(2):
                for dj in range(2):
                    if i * 2 + di < input_rows and j * 2 + dj < input_cols:
                        merged_value = max(merged_value, cleaned_grid[i * 2 + di][j * 2 + dj])
            row.append(merged_value)
        output_grid.append(row)

    return output_grid",0.0,0
6b9890af,4,"def transform(input_grid):
    # Remove all rows that are entirely zeros
    input_grid = [row for row in input_grid if any(row)]

    # Transpose the grid to process columns as rows
    transposed_grid = list(map(list, zip(*input_grid)))

    # Remove all columns that are entirely zeros
    transposed_grid = [col for col in transposed_grid if any(col)]

    # Transpose back to get the cleaned grid
    cleaned_grid = list(map(list, zip(*transposed_grid)))

    # Process each row to merge adjacent non-zero values
    def process_row(row):
        new_row = []
        i = 0
        while i < len(row):
            if row[i] != 0:
                # Find the end of the sequence of non-zero values
                j = i
                while j < len(row) and row[j] != 0:
                    j += 1
                # Take the first non-zero value in the sequence
                new_row.append(row[i])
                i = j
            else:
                new_row.append(0)
                i += 1
        return new_row

    processed_grid = [process_row(row) for row in cleaned_grid]

    # Determine the maximum length of the rows
    max_length = max(len(row) for row in processed_grid)

    # Pad each row with zeros to make them the same length
    padded_grid = [row + [0] * (max_length - len(row)) for row in processed_grid]

    return padded_grid",0.0,0
6b9890af,5,"def transform(input_grid):
    def find_bounding_box(grid):
        min_row, max_row = len(grid), -1
        min_col, max_col = len(grid[0]), -1

        for i, row in enumerate(grid):
            for j, val in enumerate(row):
                if val != 0:
                    min_row = min(min_row, i)
                    max_row = max(max_row, i)
                    min_col = min(min_col, j)
                    max_col = max(max_col, j)

        return min_row, max_row, min_col, max_col

    def center_shape(grid, min_row, max_row, min_col, max_col):
        height = max_row - min_row + 1
        width = max_col - min_col + 1
        new_height = max(height, width)
        new_width = max(height, width)

        new_grid = [[2] * new_width for _ in range(new_height)]

        offset_row = (new_height - height) // 2
        offset_col = (new_width - width) // 2

        for i in range(min_row, max_row + 1):
            for j in range(min_col, max_col + 1):
                if grid[i][j] != 0:
                    new_grid[offset_row + (i - min_row)][offset_col + (j - min_col)] = grid[i][j]

        return new_grid

    min_row, max_row, min_col, max_col = find_bounding_box(input_grid)
    return center_shape(input_grid, min_row, max_row, min_col, max_col)",0.0,0
6b9890af,6,"def transform(input_grid):
    # Step 1: Remove all-zero rows and columns
    non_zero_rows = [row for row in input_grid if any(cell != 0 for cell in row)]
    non_zero_cols = [col for col in zip(*non_zero_rows) if any(cell != 0 for cell in col)]

    # Step 2: Reconstruct the grid with non-zero rows and columns
    reconstructed_grid = [list(col) for col in zip(*non_zero_cols)]

    # Step 3: Merge adjacent non-zero values into a single value
    merged_grid = []
    for row in reconstructed_grid:
        merged_row = []
        i = 0
        while i < len(row):
            if row[i] != 0:
                merged_row.append(row[i])
                while i + 1 < len(row) and row[i + 1] == row[i]:
                    i += 1
            else:
                merged_row.append(0)
            i += 1
        merged_grid.append(merged_row)

    # Step 4: Rearrange the non-zero values to form a new shape
    max_row_length = max(len(row) for row in merged_grid)
    output_grid = []
    for row in merged_grid:
        if len(row) < max_row_length:
            row.extend([0] * (max_row_length - len(row)))
        output_grid.append(row)

    return output_grid",0.0,0
6b9890af,7,"def transform(input_grid):
    # Remove empty rows and columns from the edges
    while all(x == 0 for x in input_grid[0]):
        input_grid.pop(0)
    while all(x == 0 for x in input_grid[-1]):
        input_grid.pop(-1)
    while all(row[0] == 0 for row in input_grid):
        input_grid = [row[1:] for row in input_grid]
    while all(row[-1] == 0 for row in input_grid):
        input_grid = [row[:-1] for row in input_grid]

    # Determine the dimensions of the output grid
    output_rows = len(input_grid) // 2
    output_cols = len(input_grid[0]) // 2

    # Initialize the output grid
    output_grid = [[0] * output_cols for _ in range(output_rows)]

    # Merge every 2 rows into 1 row and every 2 columns into 1 column
    for i in range(output_rows):
        for j in range(output_cols):
            # Find the first non-zero element in the merged 2x2 block
            for ii in range(2):
                for jj in range(2):
                    if input_grid[2 * i + ii][2 * j + jj] != 0:
                        output_grid[i][j] = input_grid[2 * i + ii][2 * j + jj]
                        break
                if output_grid[i][j] != 0:
                    break

    return output_grid",0.10666666666666667,0
6b9890af,8,"def transform(input_grid):
    # Remove rows and columns that are entirely zeros
    non_zero_rows = [row for row in input_grid if any(cell != 0 for cell in row)]
    non_zero_cols = [col for col in zip(*non_zero_rows) if any(cell != 0 for cell in col)]

    # Transpose back to get the cleaned grid
    cleaned_grid = [list(row) for row in zip(*non_zero_cols)]

    # Determine the output grid size
    output_rows = len(cleaned_grid) // 2
    output_cols = len(cleaned_grid[0]) // 2

    # Initialize the output grid with zeros
    output_grid = [[0] * output_cols for _ in range(output_rows)]

    # Fill the output grid with merged values and boundary values
    for i in range(output_rows):
        for j in range(output_cols):
            # Get the 2x2 block from the input grid
            block = [cleaned_grid[2*i+k][2*j:2*j+2] for k in range(2)]
            # Merge the block into a single value
            merged_value = max(block[0][0], block[0][1], block[1][0], block[1][1])
            output_grid[i][j] = merged_value

    # Add boundary values of 2 around the merged values
    for i in range(output_rows):
        output_grid[i][0] = 2
        output_grid[i][-1] = 2
    for j in range(output_cols):
        output_grid[0][j] = 2
        output_grid[-1][j] = 2

    return output_grid",0.0,0
6b9890af,9,"def transform(input_grid):
    import numpy as np

    # Determine the dimensions of the input grid
    input_height = len(input_grid)
    input_width = len(input_grid[0])

    # Determine the dimensions of the output grid
    output_height = input_height // 3
    output_width = input_width // 3

    # Crop the input grid from the center
    crop_top = (input_height - output_height) // 2
    crop_left = (input_width - output_width) // 2
    cropped_grid = [row[crop_left:crop_left + output_width] for row in input_grid[crop_top:crop_top + output_height]]

    # Scale the cropped grid down
    scaled_grid = np.array(cropped_grid).reshape(output_height, output_width).tolist()

    return scaled_grid",0.0,0
6b9890af,10,,0.0,0
98cf29f8,1,,0.0,0
98cf29f8,2,,0.0,0
98cf29f8,3,,0.0,0
98cf29f8,4,"def transform(grid):
    # Find the last non-zero row
    last_non_zero_row = -1
    for i, row in enumerate(grid):
        if any(cell != 0 for cell in row):
            last_non_zero_row = i

    # Find the last non-zero column
    last_non_zero_col = -1
    for j in range(len(grid[0])):
        if any(grid[i][j] != 0 for i in range(len(grid))):
            last_non_zero_col = j

    # Remove rows beyond the last non-zero row
    trimmed_grid = grid[:last_non_zero_row + 1]

    # Remove columns beyond the last non-zero column
    transformed_grid = [row[:last_non_zero_col + 1] for row in trimmed_grid]

    return transformed_grid",0.0,0
98cf29f8,5,,0.0,0
98cf29f8,6,,0.0,0
98cf29f8,7,,0.0,0
98cf29f8,8,"def transform(grid: list[list[int]]) -> list[list[int]]:
    rows = len(grid)
    cols = len(grid[0])

    # Create a copy of the grid to store the transformed result
    transformed_grid = [row[:] for row in grid]

    # Define movement directions based on block type
    movement = {
        4: (1, 0),  # Downwards
        5: (-1, 0), # Upwards
        3: (-1, 0)  # Upwards
    }

    # Iterate through each element in the grid
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] in movement:
                dr, dc = movement[grid[r][c]]
                nr, nc = r + dr, c + dc

                # Move the block until it hits another block or the boundary
                while 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                    transformed_grid[nr][nc] = grid[r][c]
                    transformed_grid[r][c] = 0
                    r, c = nr, nc
                    nr, nc = r + dr, c + dc

    return transformed_grid",0.88,0
98cf29f8,9,"def transform(grid):
    # Find the last non-zero row
    last_non_zero_row = -1
    for i, row in enumerate(grid):
        if any(cell != 0 for cell in row):
            last_non_zero_row = i

    # Find the last non-zero column
    last_non_zero_col = -1
    for j in range(len(grid[0])):
        if any(row[j] != 0 for row in grid):
            last_non_zero_col = j

    # Remove rows that contain only zeros after the last non-zero row
    transformed_grid = [row for i, row in enumerate(grid) if i <= last_non_zero_row]

    # Remove columns that contain only zeros after the last non-zero column
    transformed_grid = [row[:last_non_zero_col + 1] for row in transformed_grid]

    return transformed_grid",0.0,0
98cf29f8,10,,0.0,0
06df4c85,1,,0.0,0
06df4c85,2,,0.0,0
06df4c85,3,,0.0,0
06df4c85,4,,0.0,0
06df4c85,5,,0.0,0
06df4c85,6,,0.0,0
06df4c85,7,,0.0,0
06df4c85,8,,0.0,0
06df4c85,9,,0.0,0
06df4c85,10,,0.0,0
b6afb2da,1,"def transform(input_grid):
    def is_boundary(i, j):
        if input_grid[i][j] != 5:
            return False
        if i > 0 and input_grid[i-1][j] == 0:
            return True
        if i < len(input_grid) - 1 and input_grid[i+1][j] == 0:
            return True
        if j > 0 and input_grid[i][j-1] == 0:
            return True
        if j < len(input_grid[0]) - 1 and input_grid[i][j+1] == 0:
            return True
        return False

    def is_corner(i, j):
        if input_grid[i][j] != 5:
            return False
        if i > 0 and j > 0 and input_grid[i-1][j-1] == 0:
            return True
        if i > 0 and j < len(input_grid[0]) - 1 and input_grid[i-1][j+1] == 0:
            return True
        if i < len(input_grid) - 1 and j > 0 and input_grid[i+1][j-1] == 0:
            return True
        if i < len(input_grid) - 1 and j < len(input_grid[0]) - 1 and input_grid[i+1][j+1] == 0:
            return True
        return False

    output_grid = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]

    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 5:
                if is_corner(i, j):
                    output_grid[i][j] = 1
                elif is_boundary(i, j):
                    output_grid[i][j] = 4
                else:
                    output_grid[i][j] = 2

    return output_grid",0.765,0
b6afb2da,2,"def transform(input_grid):
    def get_transformed_value(x, y, grid):
        if grid[x][y] == 0:
            return 0
        if x == 0 and y == 0:
            return 1
        if x == 0 and y == len(grid[0]) - 1:
            return 1
        if x == len(grid) - 1 and y == 0:
            return 1
        if x == len(grid) - 1 and y == len(grid[0]) - 1:
            return 1
        if x == 0 or x == len(grid) - 1:
            return 4
        if y == 0 or y == len(grid[0]) - 1:
            return 4
        return 2

    output_grid = []
    for i in range(len(input_grid)):
        row = []
        for j in range(len(input_grid[0])):
            row.append(get_transformed_value(i, j, input_grid))
        output_grid.append(row)
    return output_grid",0.805,0
b6afb2da,3,"def transform(input_grid):
    def get_neighbors(x, y, grid):
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
                    neighbors.append((nx, ny))
        return neighbors

    def is_corner(x, y, grid):
        if grid[x][y] != 5:
            return False
        neighbors = get_neighbors(x, y, grid)
        empty_neighbors = [n for n in neighbors if grid[n[0]][n[1]] == 0]
        return len(empty_neighbors) > 1

    output_grid = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]

    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 5:
                if is_corner(i, j, input_grid):
                    output_grid[i][j] = 4
                else:
                    output_grid[i][j] = 2
                for ni, nj in get_neighbors(i, j, input_grid):
                    if input_grid[ni][nj] == 0:
                        output_grid[ni][nj] = 1

    return output_grid",0.6,0
b6afb2da,4,"def transform(input_grid):
    def is_boundary(i, j, grid):
        if grid[i][j] != 5:
            return False
        if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:
            return True
        if grid[i-1][j] == 0 or grid[i+1][j] == 0 or grid[i][j-1] == 0 or grid[i][j+1] == 0:
            return True
        return False

    rows = len(input_grid)
    cols = len(input_grid[0])
    output_grid = [[0] * cols for _ in range(rows)]

    for i in range(rows):
        for j in range(cols):
            if input_grid[i][j] == 5:
                if is_boundary(i, j, input_grid):
                    if (i == 0 or i == rows - 1) and (j == 0 or j == cols - 1):
                        output_grid[i][j] = 1
                    else:
                        output_grid[i][j] = 4
                else:
                    output_grid[i][j] = 2
            else:
                output_grid[i][j] = 0

    return output_grid",0.935,0
b6afb2da,5,"def transform(input_grid):
    def get_neighbors(x, y, grid):
        neighbors = []
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
                neighbors.append((nx, ny))
        return neighbors

    def bfs(start_x, start_y, grid):
        queue = [(start_x, start_y)]
        visited = set()
        while queue:
            x, y = queue.pop(0)
            if (x, y) in visited:
                continue
            visited.add((x, y))
            for nx, ny in get_neighbors(x, y, grid):
                if grid[nx][ny] == 5 and (nx, ny) not in visited:
                    queue.append((nx, ny))
        return visited

    def transform_component(component, grid):
        min_x = min(x for x, y in component)
        max_x = max(x for x, y in component)
        min_y = min(y for x, y in component)
        max_y = max(y for x, y in component)

        for x, y in component:
            if x == min_x or x == max_x or y == min_y or y == max_y:
                grid[x][y] = 1
            elif x == min_x + 1 or x == max_x - 1 or y == min_y + 1 or y == max_y - 1:
                grid[x][y] = 4
            else:
                grid[x][y] = 2

    output_grid = [row[:] for row in input_grid]

    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 5:
                component = bfs(i, j, input_grid)
                transform_component(component, output_grid)

    return output_grid",0.64,0
b6afb2da,6,"def transform(grid):
    def is_valid(x, y, grid):
        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 5

    def transform_block(x, y, grid, visited):
        stack = [(x, y)]
        boundaries = set()
        while stack:
            cx, cy = stack.pop()
            if (cx, cy) in visited:
                continue
            visited.add((cx, cy))
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = cx + dx, cy + dy
                if is_valid(nx, ny, grid):
                    stack.append((nx, ny))
                else:
                    boundaries.add((cx, cy))

        for bx, by in boundaries:
            if (bx, by) not in visited:
                grid[bx][by] = 4
            else:
                grid[bx][by] = 2

        for bx, by in boundaries:
            if (bx, by) in visited:
                grid[bx][by] = 1

    visited = set()
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 5 and (i, j) not in visited:
                transform_block(i, j, grid, visited)

    return grid",0.63,0
b6afb2da,7,"def transform(input_grid):
    def process_row(row):
        if 5 not in row:
            return row
        start = row.index(5)
        end = len(row) - 1 - row[::-1].index(5)
        new_row = [0] * len(row)
        new_row[start] = 1
        new_row[end] = 1
        for i in range(start + 1, end):
            new_row[i] = 4 if row[i] == 5 else 2
        return new_row

    return [process_row(row) for row in input_grid]",0.63,0
b6afb2da,8,"def transform(input_grid):
    def is_corner(x, y, grid):
        if grid[x][y] == 0:
            return False
        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
        empty_neighbors = [grid[i][j] == 0 for i, j in neighbors if 0 <= i < len(grid) and 0 <= j < len(grid[0])]
        return sum(empty_neighbors) == 2

    def is_edge(x, y, grid):
        if grid[x][y] == 0:
            return False
        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
        empty_neighbors = [grid[i][j] == 0 for i, j in neighbors if 0 <= i < len(grid) and 0 <= j < len(grid[0])]
        return sum(empty_neighbors) == 1

    def is_interior(x, y, grid):
        if grid[x][y] == 0:
            return False
        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
        empty_neighbors = [grid[i][j] == 0 for i, j in neighbors if 0 <= i < len(grid) and 0 <= j < len(grid[0])]
        return sum(empty_neighbors) == 0

    output_grid = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]

    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if is_corner(i, j, input_grid):
                output_grid[i][j] = 1
            elif is_edge(i, j, input_grid):
                output_grid[i][j] = 4
            elif is_interior(i, j, input_grid):
                output_grid[i][j] = 2
            else:
                output_grid[i][j] = input_grid[i][j]

    return output_grid",0.865,0
b6afb2da,9,"def transform(input_grid):
    def get_neighbors(x, y, grid):
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
                    neighbors.append(grid[nx][ny])
        return neighbors

    output_grid = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]

    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 5:
                neighbors = get_neighbors(i, j, input_grid)
                count_5 = neighbors.count(5)
                if count_5 == 2:
                    output_grid[i][j] = 1  # Corner
                elif count_5 == 1:
                    output_grid[i][j] = 4  # Edge
                else:
                    output_grid[i][j] = 2  # Interior
            else:
                output_grid[i][j] = 0  # Empty space

    return output_grid",0.7,0
b6afb2da,10,"def transform(input_grid):
    def get_value(row, col, grid):
        if grid[row][col] == 0:
            return 0
        if row == 0 or row == len(grid) - 1 or col == 0 or col == len(grid[0]) - 1:
            return 1
        if grid[row-1][col] == 0 or grid[row+1][col] == 0 or grid[row][col-1] == 0 or grid[row][col+1] == 0:
            return 4
        return 2

    output_grid = []
    for row in range(len(input_grid)):
        output_row = []
        for col in range(len(input_grid[0])):
            output_row.append(get_value(row, col, input_grid))
        output_grid.append(output_row)
    return output_grid",0.875,0
7df24a62,1,,0.0,0
7df24a62,2,,0.0,0
7df24a62,3,,0.0,0
7df24a62,4,,0.0,0
7df24a62,5,,0.0,0
7df24a62,6,,0.0,0
7df24a62,7,,0.0,0
7df24a62,8,,0.0,0
7df24a62,9,,0.0,0
7df24a62,10,,0.0,0
e8593010,1,"import random

def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row = []
        for cell in row:
            if cell == 0:
                new_row.append(random.choice([1, 2, 3]))
            else:
                new_row.append(cell)
        output_grid.append(new_row)
    return output_grid",0.0,0
e8593010,2,"import random

def transform(input_grid):
    def is_valid(grid, row, col, num):
        if row > 0 and grid[row - 1][col] == num:
            return False
        if row < len(grid) - 1 and grid[row + 1][col] == num:
            return False
        if col > 0 and grid[row][col - 1] == num:
            return False
        if col < len(grid[row]) - 1 and grid[row][col + 1] == num:
            return False
        return True

    output_grid = [row[:] for row in input_grid]

    for i in range(len(input_grid)):
        for j in range(len(input_grid[i])):
            if input_grid[i][j] == 0:
                valid_numbers = [num for num in [1, 2, 3] if is_valid(output_grid, i, j, num)]
                if valid_numbers:
                    output_grid[i][j] = random.choice(valid_numbers)

    return output_grid",0.0,0
e8593010,3,"import random

def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row = []
        for cell in row:
            if cell == 0:
                new_row.append(random.choice([1, 2, 3]))
            else:
                new_row.append(cell)
        output_grid.append(new_row)
    return output_grid",0.0,0
e8593010,4,"def transform(grid):
    def get_neighbors(x, y):
        neighbors = []
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
                neighbors.append(grid[nx][ny])
        return neighbors

    transformed_grid = [row[:] for row in grid]

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 0:
                neighbors = get_neighbors(i, j)
                if all(n == 5 for n in neighbors):
                    if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:
                        transformed_grid[i][j] = 1
                    elif neighbors.count(0) == 0:
                        transformed_grid[i][j] = 3
                    else:
                        transformed_grid[i][j] = 2
                elif neighbors.count(0) == 1:
                    transformed_grid[i][j] = 1
                elif neighbors.count(0) == 2:
                    transformed_grid[i][j] = 2
                elif neighbors.count(0) == 3:
                    transformed_grid[i][j] = 3

    return transformed_grid",0.83,0
e8593010,5,"import random

def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row = []
        for cell in row:
            if cell == 0:
                new_row.append(random.choice([1, 2, 3]))
            else:
                new_row.append(cell)
        output_grid.append(new_row)
    return output_grid",0.0,0
e8593010,6,"def transform(grid):
    def get_replacement_value(row, col):
        if grid[row][col] != 0:
            return grid[row][col]

        # Check neighbors
        neighbors = [
            (row-1, col), (row+1, col), (row, col-1), (row, col+1),
            (row-1, col-1), (row-1, col+1), (row+1, col-1), (row+1, col+1)
        ]

        five_count = sum(1 for r, c in neighbors if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 5)

        if five_count == 0:
            return 1
        elif five_count == 1:
            return 2
        elif five_count == 2:
            return 3
        else:
            return 1

    transformed_grid = []
    for i, row in enumerate(grid):
        new_row = []
        for j, value in enumerate(row):
            if value == 0:
                new_row.append(get_replacement_value(i, j))
            else:
                new_row.append(value)
        transformed_grid.append(new_row)

    return transformed_grid",0.8066666666666666,0
e8593010,7,"def transform(input_grid):
    def nearest_five_distance(x, y, grid):
        rows, cols = len(grid), len(grid[0])
        min_distance = float('inf')
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 5:
                    distance = abs(i - x) + abs(j - y)
                    if distance < min_distance:
                        min_distance = distance
        return min_distance

    rows, cols = len(input_grid), len(input_grid[0])
    output_grid = [[0] * cols for _ in range(rows)]

    for i in range(rows):
        for j in range(cols):
            if input_grid[i][j] == 0:
                distance = nearest_five_distance(i, j, input_grid)
                if distance == 1:
                    output_grid[i][j] = 3
                elif distance == 2:
                    output_grid[i][j] = 2
                else:
                    output_grid[i][j] = 1
            else:
                output_grid[i][j] = input_grid[i][j]

    return output_grid",0.8166666666666668,0
e8593010,8,"def transform(input_grid):
    def get_value(row, col, grid):
        if grid[row][col] != 0:
            return grid[row][col]

        # Count the number of adjacent 5s
        adjacent_5s = 0
        for i in range(max(0, row-1), min(len(grid), row+2)):
            for j in range(max(0, col-1), min(len(grid[0]), col+2)):
                if grid[i][j] == 5:
                    adjacent_5s += 1

        # Check if it's at the end of a row or column
        is_end = (row == 0 or row == len(grid) - 1 or col == 0 or col == len(grid[0]) - 1)

        # Check if it's in a corner
        is_corner = (row == 0 and col == 0) or (row == 0 and col == len(grid[0]) - 1) or \
                    (row == len(grid) - 1 and col == 0) or (row == len(grid) - 1 and col == len(grid[0]) - 1)

        if is_corner:
            return 3
        elif is_end and adjacent_5s >= 1:
            return 2
        elif adjacent_5s >= 2:
            return 1
        else:
            return 3

    output_grid = []
    for i in range(len(input_grid)):
        row = []
        for j in range(len(input_grid[i])):
            row.append(get_value(i, j, input_grid))
        output_grid.append(row)

    return output_grid",0.84,0
e8593010,9,"import random

def transform(input_grid):
    output_grid = []
    for row in input_grid:
        new_row = []
        for cell in row:
            if cell == 0:
                new_row.append(random.choice([1, 2, 3]))
            else:
                new_row.append(cell)
        output_grid.append(new_row)
    return output_grid",0.0,0
e8593010,10,"def transform(grid: list[list[int]]) -> list[list[int]]:
    def count_adjacent_fives(row, col):
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        count = 0
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 5:
                count += 1
        return count

    transformed_grid = [row[:] for row in grid]

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 0:
                adjacent_fives = count_adjacent_fives(i, j)
                if adjacent_fives == 2:
                    transformed_grid[i][j] = 1
                elif adjacent_fives == 3:
                    transformed_grid[i][j] = 2
                elif adjacent_fives == 4:
                    transformed_grid[i][j] = 3

    return transformed_grid",0.8733333333333334,0
746b3537,1,"def transform(grid):
    unique_rows = []
    seen = set()

    for row in grid:
        row_tuple = tuple(row)
        if row_tuple not in seen:
            seen.add(row_tuple)
            unique_rows.append(row)

    result = []
    for row in unique_rows:
        unique_elements = []
        for element in row:
            if element not in unique_elements:
                unique_elements.append(element)
        result.append(unique_elements)

    return result",0.8,4
746b3537,2,"def transform(input_grid):
    unique_rows = []
    seen = set()

    for row in input_grid:
        unique_row = list(set(row))
        unique_row_tuple = tuple(unique_row)
        if unique_row_tuple not in seen:
            seen.add(unique_row_tuple)
            unique_rows.append(unique_row)

    return unique_rows",0.6,3
746b3537,3,"def transform(input_grid):
    unique_rows = []
    for row in input_grid:
        unique_row = list(dict.fromkeys(row))  # Remove duplicate elements within the row
        if unique_row not in unique_rows:
            unique_rows.append(unique_row)
    return unique_rows",0.8,4
746b3537,4,"def transform(grid: list[list[int]]) -> list[list[int]]:
    def remove_duplicates(row):
        return list(dict.fromkeys(row))

    unique_rows = []
    seen = set()

    for row in grid:
        cleaned_row = tuple(remove_duplicates(row))
        if cleaned_row not in seen:
            unique_rows.append(list(cleaned_row))
            seen.add(cleaned_row)

    return unique_rows",0.8,4
746b3537,5,"def transform(input_grid):
    if all(row == input_grid[0] for row in input_grid):
        return [list(set(input_grid[0]))]
    else:
        return [list(set(row)) for row in input_grid]",0.4,2
746b3537,6,"def transform(input_grid):
    if all(row == input_grid[0] for row in input_grid):
        return [list(set(input_grid[0]))]
    else:
        return [list(set(row)) for row in input_grid]",0.4,2
746b3537,7,"def transform(input_grid: list[list[int]]) -> list[list[int]]:
    # Step 1: Remove duplicate columns within each row
    unique_rows = []
    for row in input_grid:
        unique_row = []
        for item in row:
            if item not in unique_row:
                unique_row.append(item)
        unique_rows.append(unique_row)

    # Step 2: Remove duplicate rows
    unique_rows = [list(row) for row in {tuple(row) for row in unique_rows}]

    return unique_rows",0.5660000000000001,2
746b3537,8,"def transform(input_grid):
    # Remove duplicate rows
    unique_rows = []
    for row in input_grid:
        if row not in unique_rows:
            unique_rows.append(row)

    # Remove duplicate elements within each row
    transformed_grid = []
    for row in unique_rows:
        unique_elements = []
        for element in row:
            if element not in unique_elements:
                unique_elements.append(element)
        transformed_grid.append(unique_elements)

    return transformed_grid",0.8,4
746b3537,9,"def transform(grid):
    def unique_elements(row):
        return list(set(row))

    return [unique_elements(row) for row in grid]",0.2,1
746b3537,10,"def transform(input_grid):
    if all(row == input_grid[0] for row in input_grid):
        return [list(set(input_grid[0]))]
    else:
        return [list(set(row)) for row in input_grid]",0.4,2
025d127b,1,"def transform(grid: list[list[int]]) -> list[list[int]]:
    transformed_grid = []
    for row in grid:
        new_row = []
        non_zero_values = [value for value in row if value != 0]
        new_row.extend(non_zero_values)
        new_row.extend([0] * (len(row) - len(non_zero_values)))
        transformed_grid.append(new_row)
    return transformed_grid",0.685,0
025d127b,2,"def transform(grid: list[list[int]]) -> list[list[int]]:
    rows = len(grid)
    cols = len(grid[0])
    transformed_grid = [[0] * cols for _ in range(rows)]

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] != 0:
                if j > 0 and grid[i][j-1] == 0:
                    transformed_grid[i][j-1] = grid[i][j]
                else:
                    transformed_grid[i][j] = grid[i][j]

    return transformed_grid",0.795,0
025d127b,3,"def transform(grid: list[list[int]]) -> list[list[int]]:
    def shift_row_left(row):
        # Remove leading zeros
        non_zero_elements = [x for x in row if x != 0]
        # Add trailing zeros to match the original row length
        return non_zero_elements + [0] * (len(row) - len(non_zero_elements))

    return [shift_row_left(row) for row in grid]",0.685,0
025d127b,4,"def transform(grid: list[list[int]]) -> list[list[int]]:
    transformed_grid = []
    for row in grid:
        # Remove zeros and keep non-zero values
        non_zero_values = [value for value in row if value != 0]
        # Create a new row with non-zero values shifted to the left
        new_row = non_zero_values + [0] * (len(row) - len(non_zero_values))
        transformed_grid.append(new_row)
    return transformed_grid",0.685,0
025d127b,5,"def transform(input_grid):
    transformed_grid = []
    for row in input_grid:
        # Remove zeros and keep non-zero values
        non_zero_values = [value for value in row if value != 0]
        # Create a new row with non-zero values shifted to the left
        new_row = non_zero_values + [0] * (len(row) - len(non_zero_values))
        transformed_grid.append(new_row)
    return transformed_grid",0.685,0
025d127b,6,"def transform(grid: list[list[int]]) -> list[list[int]]:
    transformed_grid = []
    for row in grid:
        new_row = []
        non_zero_values = [value for value in row if value != 0]
        zero_count = row.count(0)
        new_row = [0] * zero_count + non_zero_values
        transformed_grid.append(new_row)
    return transformed_grid",0.78,0
025d127b,7,"def transform(grid):
    rows = len(grid)
    cols = len(grid[0])
    output = [[0] * cols for _ in range(rows)]

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] != 0:
                if c > 0 and grid[r][c-1] == 0:
                    output[r][c-1] = grid[r][c]
                elif r > 0 and grid[r-1][c] == 0:
                    output[r-1][c] = grid[r][c]
                else:
                    output[r][c] = grid[r][c]

    return output",0.665,0
025d127b,8,"def transform(grid: list[list[int]]) -> list[list[int]]:
    rows = len(grid)
    cols = len(grid[0])
    output = [[0] * cols for _ in range(rows)]

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] != 0:
                if c > 0 and grid[r][c-1] == 0 and (c == cols-1 or grid[r][c+1] == 0):
                    output[r][c-1] = grid[r][c]
                elif r > 0 and grid[r-1][c] == 0 and (r == rows-1 or grid[r+1][c] == 0):
                    output[r-1][c] = grid[r][c]
                elif c > 0 and r > 0 and grid[r-1][c-1] == 0 and (c == cols-1 or r == rows-1 or grid[r+1][c+1] == 0):
                    output[r-1][c-1] = grid[r][c]
                else:
                    output[r][c] = grid[r][c]

    return output",0.6799999999999999,0
025d127b,9,"def transform(grid: list[list[int]]) -> list[list[int]]:
    def shift_row(row):
        first_non_zero_index = -1
        for i, value in enumerate(row):
            if value != 0:
                first_non_zero_index = i
                break

        if first_non_zero_index == -1:
            return row

        shifted_row = [0] * len(row)
        shifted_row[first_non_zero_index] = row[first_non_zero_index]
        shift_index = first_non_zero_index + 1

        for i in range(first_non_zero_index + 1, len(row)):
            if row[i] != 0:
                shifted_row[shift_index] = row[i]
                shift_index += 1

        return shifted_row

    return [shift_row(row) for row in grid]",0.895,0
025d127b,10,"def transform(grid: list[list[int]]) -> list[list[int]]:
    transformed_grid = []
    for row in grid:
        new_row = []
        non_zero_values = [value for value in row if value != 0]
        zero_count = row.count(0)
        new_row.extend([0] * (len(row) - len(non_zero_values)))
        new_row.extend(non_zero_values)
        transformed_grid.append(new_row)
    return transformed_grid",0.78,0
