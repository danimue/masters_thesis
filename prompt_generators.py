import json
import base64
import matplotlib.pyplot as plt
import numpy as np
from typing import Dict, List, Any
from helper_functions import *

# converts dict to a nicely formatted string for prompt creation
def json_to_string(task: dict, include_test: bool = False) -> str:
    """
    Converts a given ARC-task from its json-like form to a string, so that it can be used in a prompt.

    Parameters:
        - task (dict): the task from train or eval set
        - include_test (bool): by default, the test case will not be included
    """

    train_tasks = task["train"]
    test_task = task["test"]

    # Training Examples
    final_output = "Training Examples\n"
    for i, task in enumerate(train_tasks):
        final_output += f"Example {i + 1}: Input\n["
        for index, row in enumerate(task["input"]):
            if index == len(task["input"])-1:
                final_output += f"\n{str(row)}"
            else:
                final_output += f"\n{str(row)},"
        final_output += "]\n\n"
        final_output += f"Example {i + 1}: Output\n["
        for index, row in enumerate(task["output"]):
            if index == len(task["output"])-1:
                final_output += f"\n{str(row)}"
            else:
                final_output += f"\n{str(row)},"
        final_output += "]\n\n"

    # Test Example
    if include_test:
        final_output += "Test\n["
        for index, row in enumerate(test_task[0]["input"]):
            if index == len(test_task[0]["input"])-1:
                final_output += f"\n{str(row)}"
            else:
                final_output += f"\n{str(row)},"
        final_output += "]"

    return final_output


def json_to_ascii(task: dict[str, Any], include_test: bool = False) -> str:
    
    result_str = "Training examples as character representation:\n"
    
    # TODO: come up with better letters? maybe b for black etc.
    letter_mapping = {0: ' ', 1: 'b', 2: 'c', 3: 'd', 4: 'e',
                      5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j'}
    
    # Training examples
    for i, element in enumerate(task["train"]):        
        result_str += f"Example {i + 1}: Input\n"
        
        # Input
        for line in element["input"]:
            for index, int in enumerate(line):
                if index == len(line) -1:
                    result_str += letter_mapping[int]
                else:
                    result_str += letter_mapping[int] + "|"
            result_str += "\n"
        result_str += "\n\n"
        
        # Output
        result_str += f"Example {i + 1}: Output\n"
        for line in element["output"]:
            for index, int in enumerate(line):
                if index == len(line) -1:
                    result_str += letter_mapping[int]
                else:
                    result_str += letter_mapping[int] + "|"
            result_str += "\n"
        result_str += "\n\n"
        
    # Test case
    if include_test:
        result_str += "Test case:\n"
        
        for line in task["test"][0]["input"]:
            for index, int in enumerate(line):
                if index == len(line) -1:
                    result_str += letter_mapping[int]
                else:
                    result_str += letter_mapping[int] + "|"
            result_str += "\n"

    return result_str


def find_task(task_identifier: str, *dicts: dict[str, Any]) -> dict[str, Any] | None:
    """
    Searches for task because it could be in either train or eval dict.

    Parameters:
        task_identifier (str): easy way to access the task via their string
        *dicts (dict[str, Any]): should always be train and eval dictionary

    Returns:
        part of the dict that the task is in or
        None if task was not found
    """
    for d in dicts:
        if task_identifier in d:
            return d[task_identifier]
    return None


def generate_expected_and_generated_outputs(task: dict[str, Any], generated_inputs: list) -> str:
    
    train_tasks = task['train']

    # Training Examples
    final_output = ""
    for i, task in enumerate(train_tasks):
        final_output += f"Example {i+1}: Expected Output\n["
        for index, row in enumerate(task["output"]):
            if index == len(task["output"])-1:
                final_output += f"\n{str(row)}"
            else:
                final_output += f"\n{str(row)},"
        final_output += f"]\n\nExample {i + 1}: Output generated by code\n[\n"
        
        if generated_inputs[i] is None:
            final_output += "No output generated.\n"
        else:
            for line_count,line in enumerate(generated_inputs[i]):
                if line_count == len(generated_inputs[i])-1:
                    final_output += str(line)
                else:
                    final_output += str(line) + ",\n"
        final_output += "]\n\n"
        
    return final_output

def format_outputs_for_prompt(generated_outputs: list) -> str:
    formatted_outputs = ""
    
    for i, output in enumerate(generated_outputs):
        formatted_outputs += f"Example {i+1} - Generated Output:\n[\n"
        if output is None:
            formatted_outputs += "No output generated.\n"
        else:
            for line_count, line in enumerate(output):
                if line_count == len(output)-1:
                    formatted_outputs += str(line)
                else:
                    formatted_outputs += str(line) + ",\n"
        formatted_outputs += "]\n\n"
    
    return formatted_outputs
        

def generate_code_fixing_prompt(task: dict[str, Any], extracted_answer: str, generated_inputs: list) -> list[dict]:
    
    system_prompt = """You are a very talented python programmer and puzzle solver. You were given a task but did not get the correct solution. The task consists of multiple paired example input and outputs. The outputs were produced by applying a transformation rule to the inputs. The task is to determine the transformation rule and implement it in code. The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors."""

    integer_grids = json_to_string(task, include_test=False)
    
    expected_and_generated_outputs = generate_expected_and_generated_outputs(task, generated_inputs)
    
    user_prompt = f"""Here are the examples of input and output grids represented as list[list[int]]:

{integer_grids}

This is the answer you gave:

{extracted_answer}

Unfortunately, the code in this answer does not produce the exact correct results. Here are the the expected and produced outputs that the code produced:

{expected_and_generated_outputs}

Can you spot the problem? Please consider that a mistake can stem from the initial reasoning or the implementation in code. Carefully examine both the reasoning and the implementation.
Once you are done, please write correct code. Again, format your code within triple backticks (```python <your code> ```) and write one function that is named "transform_grid()".
You do not need to test the code, it will be tested for you later.
"""

    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": [{"type": "text", "text": user_prompt}]}
    ]

    return messages

def generate_continued_code_fixing_prompt(generated_inputs: list) -> str:
    
    formatted_outputs = format_outputs_for_prompt(generated_inputs)
    
    user_prompt = f"""It seems like the answer is still not quite correct. The generated outputs now look like this:
    
{formatted_outputs}
Please examine the output generated by the code you produced. Think about what went wrong. Consider that the problem may still either be in the initial hypothesis OR its implementation in code.
Reason carefully and for as long as necessary. Put that initial reasoning within <reasoning></reasoning> tags. Then correct the code accordingly. Make sure the corrected code you produce is still in a function named 'transform_grid()' and out all of the code within triple backticks (```python ```)."""

    return user_prompt

def generate_coding_prompt(task: dict[str, Any]) -> list[dict]:
    
    system_prompt = """You are a very talented python programmer. You will be given multiple paired example input and outputs. The outputs were produced by applying a transformation rule to the inputs. Your task is to determine the transformation rule and implement it in code. The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors. 
The transformation rule that you have to deduce might have multiple components and can be fairly complex. In your reasoning you will break down complex problems into smaller parts and reason through them step by step, arriving at sub-conclusions before stating your overall conclusion. This will avoid large leaps in reasoning. You reason in detail and for as long as is necessary to fully determine the transformation rule."""
    
    integer_grids = json_to_string(task, include_test=False)
        
    user_prompt = f"""Here are the examples of input and output grids represented as list[list[int]]:

{integer_grids}

You will need to carefully reason in detail to determine the transformation rule. Put your reasoning in <reasoning></reasoning> tags. You break down complex problems into smaller parts and reason through them step by step, using sub-conclusions before coming to an overall conclusion. Large leaps in reasoning are not necessary. Reason for as long as necessary.

- Determine the input and output grid sizes.
- Focus on what stays permanent and changes between input and output.
- Deduce a transformation rule and confirm that it works on the examples given.

If you find that you made a mistake in your previous reasoning, correct it. Make sure your reasoning does not only work on one but at least multiple of the given examples.

Once you are certain you found a valid transformation rule, implement it in python code. Put your code in triple backticks (```python and then ```). Write one function named 'transform_grid()' which takes a single argument, the input grid as `list[list[int]]`, and returns the transformed grid (also as `list[list[int]]`). You do not need to document code. You also do not need to test your code - it will be tested later."""

    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt}
    ]
    
    return messages


def encode_image(image_path: str) -> str:
    """Encodes an image to base64."""
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode("utf-8")
    
    
def generate_prompt_with_image(task_id: str, task_content: dict[str, Any]) -> list[dict]:
    # Find the image that belongs to the task and convert it into a format readable for the llm
    try:
        image_path = f"task_images/{task_id}.png"
        base64_image = encode_image(image_path)
    except:
        print("Problem finding or encoding the image for this task...")
    
    # Generate the text prompt
    integer_grids = json_to_string(task_content, include_test=True)
    
    system_prompt = """You are a very talented puzzle solver. You will be given multiple paired example input and outputs. The outputs were produced by applying a transformation rule to the inputs. Your task is to determine the transformation rule and solve the last puzzle (the 'test case'). The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors.
The transformation rule that you have to deduce might have multiple components and can be fairly complex. In your reasoning you will break down complex problems into smaller parts and reason through them step by step, arriving at sub-conclusions before stating your overall conclusion. This will avoid large leaps in reasoning. You reason in detail and for as long as is necessary to fully determine the transformation rule."""
    
    user_prompt = f"""Here are the examples of input and output grids. First you will be shown the grids as integer values. Each integer value maps to a color in the image as follows:
    black: 0, blue: 1, red: 2, green: 3, yellow: 4, grey: 5, pink: 6, orange: 7, purple: 8, brown: 9.
    
Here are the grids as integers:

{integer_grids}

In addition, you are given an image of these grids. The image might not show all examples, but will give you an idea of what the tasks look like. In this image, the input grid will be on the left, the output grid on the right.

Now it is your turn. You will have to carefully reason in order to determine the transformation rule. Put your reasoning in <reasoning></reasoning> tags. You break down complex problems into smaller parts and reason through them step by step, using sub-conclusions before coming to an overall conclusion. Large leaps in reasoning are not necessary. Take as long as you deem necessary.

- First, look at the image provided to you. 
- Determine the input and output grid sizes.
- Determine what stays the same and what changes between input and output grid.
- Proceed to do the same with the integer grids. Check if your observations from image and grid align.
- Deduce a transformation rule and confirm that it works on the examples given (both the image examples and the grid examples).

When you are done reasoning in detail, solve the test case and provide the correct output.
Please format your answer the same way, the examples were initially shown to you (as a list of list of integers). Please always format your answer like this:
Answer: ``` <your answer as a list of list of integers> ``` """
    
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": [{"type": "text", "text": user_prompt}]}
    ]
    
    # Add image representation if encoding was successful
    if base64_image:
        messages[1]["content"].append({"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}})
    else:
        print("Warning: prompt that was supposed to contain image was created without image representation.")

    return messages


def create_basic_prompt(task: dict[str, Any], allow_reasoning: bool = True, reasoning_type: str = 'extended') -> str:
    
    integer_grids = json_to_string(task, include_test=True)
    
    if allow_reasoning and reasoning_type == 'extended':
        task_instructions = """Now it is your turn. You will have to carefully reason in order to determine the transformation rule. Put your reasoning in <reasoning></reasoning> tags. You break down complex problems into smaller parts and reason through them step by step, using sub-conclusions before coming to an overall conclusion. Large leaps in reasoning are not necessary. Reason for as long as you think is necessary.

In your step-by-step approach:
1. Determine the input and output grid sizes.
2. For each example grid-pair, identify what stays the same and what changes between input and output grid.
3. From your observations, determine a transformation rule.
4. Evaluate your reasoning, by checking if the transformation rule works for all examples. If you find a mistake, backtrack and think about what
could be the transformation rule again.

Then, solve the test case and provide the correct output. Please format your answer the same way, the examples were initially shown to you (as a list of list of integers). Please always format your answer like this:
Answer: ``` <your answer as a list of list of integers>```"""

    elif allow_reasoning and reasoning_type == 'simple':
        task_instructions = """Now it is your turn to solve the test case given to you. Reason step by step to determine how the examples are transformed from input to output, then give the correct answer for the test case.        
Please format your answer the same way, the examples were initially shown to you (as a list of list of integers). Please always format your answer like this:
Answer: ``` <your answer as a list of list of integers> ```"""

    else:
        task_instructions = """Now it is your turn to solve the test case given to you. Please format your answer the same way, the examples were initially shown to you (as a list of list of integers). Please always format your answer like this:
Answer: ``` <your answer as a list of list of integers> ``` Do not explain your reasoning, just output the correct grid."""

    system_prompt = "You are a very talented puzzle solver. You will be given multiple paired example input and outputs. The outputs were produced by applying a transformation rule to the inputs. Your task is to determine the transformation rule and solve the last puzzle (the 'test case'). The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors."
    
    user_prompt = f"""Here are the examples of input and output grids:
    
{integer_grids}

{task_instructions}"""

    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt}
    ]

    return messages


def create_reasoning_model_prompt_fallback(task: dict[str, Any], grid_size_str: Optional[str] = None, symmetry_str: Optional[str] = None, change_grid_str: Optional[str] = None) -> str:
    
    integer_grids = json_to_string(task, include_test=True)
    
    analysis_section_parts = []
    # Use the formatted strings directly as provided by the user's formatting functions
    if grid_size_str: analysis_section_parts.append(f"{grid_size_str}")
    if symmetry_str: analysis_section_parts.append(f"{symmetry_str}")
    if change_grid_str: analysis_section_parts.append(f"{change_grid_str}")
    
    analysis_section = ""
    if analysis_section_parts:
        # Combine analysis parts using double newline as separator
        analysis_section = "Here is some additional information about the grids:\n" + "\n\n".join(analysis_section_parts) + "\n\n---\n"

    
    task_instructions = """Now it is your turn to solve the test case given to you. Reason step by step about what the transformation rule could be. 
When you are done reasoning, apply the transformation rule to the test case and provide the correct output. Format your output the same way the examples have been shown to you, like this: Answer: ``` <your answer as a list of list of integers> ```"""

    user_prompt = f"""You are an extremely talented puzzle solver and reasoning assistant. Your task is to understand this transformation rule (which is consistent between examples) and apply the same logic to the test case to solve it.
The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors.

In your step-by-step approach:
1. Please ensure you determine the correct output grid size.
2. Focus on what stays the same and what changes between input and output grid.
3. From your observations, determine a transformation rule.
4. Evaluate your reasoning, by checking if the transformation rule works for all examples.

Here are the grids:
    
{integer_grids}

{analysis_section}

{task_instructions}    
"""

    messages = [
        {"role": "user", "content": user_prompt}
    ]

    return messages

def create_reasoning_model_prompt(task: Dict[str, Any], grid_size_str: Optional[str] = None, symmetry_str: Optional[str] = None, change_grid_str: Optional[str] = None) -> List[Dict[str, str]]:
    """ Creates the full prompt structure, incorporating optional analysis strings (user version). """
    # Use this module's json_to_string function
    integer_grids = json_to_string(task, include_test=True)

    # --- Build Analysis Section (Optional based on input strings) ---
    analysis_section_parts = []
    # Use the formatted strings directly as provided by the user's formatting functions
    if grid_size_str: analysis_section_parts.append(f"{grid_size_str}")
    if symmetry_str: analysis_section_parts.append(f"{symmetry_str}")
    if change_grid_str: analysis_section_parts.append(f"{change_grid_str}")

    analysis_section = ""
    if analysis_section_parts:
        # Combine analysis parts using double newline as separator
        analysis_section = "Here is some additional information about the grids:\n" + "\n\n".join(analysis_section_parts) + "\n\n---\n"

    # User's original instructions
    task_instructions = """Now it is your turn to solve the test case given to you. Reason step by step about what the transformation rule could be. Then write a concise summary of that transformation rule."""

    # User's original prompt structure
    user_prompt = f"""You will be given multiple example input-output pairs and an additional test input. The outputs were produced by applying a transformation rule to each of the inputs.
Your task is to understand this transformation rule (which is consistent between examples) and apply the same logic to the test case to solve it. The inputs and outputs are each 'grids'. A grid is a rectangular matrix
of integers between 0 and 9 (inclusive). The integer values represent colors.

In your step-by-step approach:
1. Please ensure you determine the correct output grid size.
2. Focus on what stays the same and what changes between input and output grid.
3. From your observations, determine a transformation rule.
4. Evaluate your reasoning, by checking if the transformation rule works for all examples.

Here are the examples of input and output grids and the test case that you have to solve:

{integer_grids}

{analysis_section}

{task_instructions}
"""
    messages = [{"role": "user", "content": user_prompt.strip()}] # Strip final prompt
    return messages


def create_reasoning_model_prompt_outdated(task: dict[str, Any]) -> str:
    
    train_grid_sizes, test_input_size = get_grid_sizes(task)
    formatted_grid_sizes = format_grid_sizes_to_string(train_grid_sizes, test_input_size)

    all_train_symmetries, test_input_symmetries= check_task_symmetries(task)
    formatted_symmetries = format_task_symmetries_to_string(all_train_symmetries, test_input_symmetries)
    
    change_grids = get_change_grid_text(task)
    
    integer_grids = json_to_string(task, include_test=True)

    user_prompt = f"""You are a very talented puzzle solver. You will be given multiple paired example input and outputs. The outputs were produced by applying a transformation rule to the inputs. Your task is to determine the transformation rule. The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors.
    Here are the examples of input and output grids:
    
{integer_grids}

Here is some additional information about the grids:
{formatted_grid_sizes}

{formatted_symmetries}

{change_grids}

Now it is your turn to examine the input-output pairs. Carefully reason step by step about what the transformation rule could be. When you are done reasoning, write a concise summary of the transformation rule. You do not need to solve the test case.
"""

    messages = [
        {"role": "user", "content": user_prompt}
    ]

    return messages

def generate_image_description_prompt(task_id: str, task: dict[str, Any]) -> str:
    try:
        image_path = f"generated_images/{task_id}.png"
        base64_image = encode_image(image_path)
    except:
        print("Problem finding or encoding the image for this task...")

    system_prompt = "You are a helpful assistant."
    user_prompt = f"""You are given an image that shows multiple paired input and output grids. The output grids were created by transforming their corresponding input grids.
For each input-output pair, identify all distinct connected regions (objects) of the same color in the input grid. Then, describe how these regions are transformed (e.g., their shape, size, position, color) in the output grid. 
If no distinct objects can be found in grids: Explicitly state that no distinct objects were identified. Keep your observations as brief as possible. Do not mention specific pixel positions."""

    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": [{"type": "text", "text": user_prompt},
                                     {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}]}
    ]

    return messages


def generate_coding_prompt_with_reasoning_info(task, transformation_rule):
    
    system_prompt = """You are a highly skilled python programmer. You will be given multiple paired example input and outputs. The outputs were produced by applying a transformation rule to the inputs. Your task is to implement that transformation rule in code. The inputs and outputs are each 'grids'. A grid is a rectangular matrix of integers between 0 and 9 (inclusive). The integer values represent colors. 
The transformation rule that you have to deduce might have multiple components and can be fairly complex. Luckily, a smart assistant has already thought about what the transformation rule might be. You need to consider this assistant's reasoning and then generate the transformation rule in code. If you find little mistakes in the description of the transformation rule, you may fix them."""
    
    integer_grids = json_to_string(task, include_test=False)
    
    user_prompt = f"""Here are the examples of input and output grids represented as list[list[int]]:

{integer_grids}

And this is the most likely transformation rule:

{transformation_rule}

Carefully look at the grids that you are given. Then implement the transformation rule shown to you in Python.
Put your code in triple backticks (```python and then ```). Write one function named 'transform_grid()' which takes a single argument, the input grid as `list[list[int]]`, and returns the transformed grid (also as `list[list[int]]`). 
You do not need to document code. You also do not need to test your code - it will be tested later. Please do not import additional modules (besides numpy if necessary)."""

    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt}
    ]
    
    return messages


