import re
import json
import numpy as np

import signal
import importlib

from typing import Any, Optional

def extract_solution(input_string: str) -> list[list[int]] | None:
    """Extracts solution (list of lists) from LLM response.

    Args:
        input_string (str): The entire answer from the LLM, expected to contain a JSON-formatted solution within triple backticks.

    Returns:
        list[list[int]] | None: The extracted list of lists if successful, otherwise None.
    """
    # This should almost never happen, but can due to server error etc:
    if input_string is None:
        print("Error: input_string is None.")
        return None
    
    # First, try to extract the answer, the way we want it to be formatted
    match = re.search(r"\s*Answer:\s*```\s*([\s\S]*?)\s*```\s*", input_string, re.S)

    # If "Answer:" is found, try to parse the captured content as JSON
    if match:
        # Try parsing json, if no json is found, we have a problem
        return match.group(1).strip()
    else:
        # If "Answer:" is not found, find the last occurrence of text between triple backticks
        # That will most likely be the answer that the LLM wants to create
        matches = re.findall(r"```\s*([\s\S]*?)\s*```", input_string, re.S)
        if matches:
            # Try parsing json, if no json is found, we have a problem
            return matches[-1].strip()

        # Last resort:
        else:
            match = re.search(r"Answer:\s*(\[[\s\S]*\])", input_string)      
            if match:
                return match.group(1).strip()
            
            else:
                # Worst case: no answer found at all :(
                print("Warning: Solution pattern not found in LLM response.")
                return None

def convert_output_to_array(input_string: str) -> np.ndarray | None:
    if input_string is None:
        return None
    else:    
        str_removed_characters = re.sub(r'[a-zA-Z]', '', input_string)
        result = str_removed_characters.strip()
        try:
            extracted_json = json.loads(result)
            grid_as_numpy_array = np.array(extracted_json)
            return grid_as_numpy_array
        except json.JSONDecodeError:
            # Often this happens because the LLM does not wrap the lists into square brackets properly
            # Therefore, attempt extracting numpy array with added brackets
            try:
                grid_with_outer_brackets = '[' + result + ']'     # but outer brackets around extracted data
                list_of_lists = eval(grid_with_outer_brackets)    # convert to list of lists
                grid_as_numpy_array = np.array(list_of_lists)
                return grid_as_numpy_array
            except:
                print("Could not successfully convert extracted answer to numpy array.")
                return None


def extract_code(input_string: str) -> str:
    """Extracts code generated by LLM.

    Args:
        input_string (str): Should be the entire answer from llm.

    Returns:
        str: Python code if formatted properly with triple backticks and python, else None
    """

    match = re.search(r"```python\s*([\s\S]*?)\s*```", input_string)  # Non-greedy match
    if match:
        return match.group(1).strip()  # Extract the captured group and clean up whitespace

    # TO-DO: think about what to do when no code is found!
    else:
        return None


class TimeoutException(Exception):
    pass

def timeout_handler(signum, frame):
    raise TimeoutException("Execution timed out")

def execute_transform_function(code_string, test_input, timeout=5):
    """Executes the 'transform' function from a code string.

    Args:
        code_string: The string containing the code with the 'transform' function.
        test_input: The input argument (list of lists) for the 'transform' function.

    Returns:
        The output of the 'transform' function, or None if an error occurs
        or the function is not found.
    """

    local_namespace = {}
    
    def dynamic_import(module_name):
        try:
            return importlib.import_module(module_name)
        except ImportError:
            print(f"Warning: Module '{module_name}' could not be imported.")
            return None #Or raise error, depending on your needs.
        
    local_namespace['__import__'] = dynamic_import
    
    # Set up signal handler for timeout - this is to prevent code that runs too long or gets into an infinite loop
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)  # Start the timer

    try:
        exec(code_string, globals(), local_namespace)  # Use globals for numpy if needed

        if 'transform_grid' in local_namespace and callable(local_namespace['transform_grid']):
            transform_func = local_namespace['transform_grid']
            output = transform_func(test_input)  # Call the function with the input
            signal.alarm(0)  # Disable the alarm
            return output
        else:
            print("Error: 'transform_grid' function not defined or not callable.")
            return None
    
    except TimeoutException:
        print("Error: Execution timed out.")
        return None
    
    except Exception as e:
        print(f"Error executing code: {e}")
        return None
    
    finally:
        signal.alarm(0)  # Ensure timeout is disabled after execution


def evaluate_solution(attempt_array: np.ndarray, solution_array: np.ndarray) -> dict:

    results = dict(
        answer_extracted = False,
        correct_grid_size = False,
        percentage_correct = 0.00
    )
    
    # Check if answer was extracted at all
    results['answer_extracted'] = attempt_array is not None

    # Check for correct grid size
    if attempt_array is not None:
        results['correct_grid_size'] = (attempt_array.shape == solution_array.shape)

    # Determine hamming similarity
    if results['correct_grid_size'] == True:
        hamming_dist = np.sum(attempt_array != solution_array)
        total_elements = attempt_array.size
        percentage_correct = (total_elements - hamming_dist) / total_elements
        results['percentage_correct'] = round(percentage_correct, 2)

    return results